const config = require('../settings')
const { cmd, commands } = require('../lib/command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')

const { exec } = require('child_process');
const axios = require('axios');
const FileType = require('file-type');
const { Sticker, StickerTypes } = require('wa-sticker-formatter');
const fs = require("fs");
const {
default: makeWASocket,
useMultiFileAuthState,
fetchLatestBaileysVersion,
DisconnectReason,
makeCacheableSignalKeyStore,
delay,
getContentType,
downloadContentFromMessage,
proto,
jidDecode
} = require('@whiskeysockets/baileys');

//Sticker Command 
var imgmsg = '';
if (config.LANG === 'SI') imgmsg = '‡∂°‡∑è‡∂∫‡∑è‡∂ª‡∑ñ‡∂¥‡∂∫‡∂ö‡∂ß mention ‡∂Ø‡∑ô‡∂±‡∑ä‡∂±!';
else imgmsg = ' Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥ò ú·¥è·¥õ·¥è “ì·¥è Ä s·¥õ…™·¥Ñ·¥ã·¥á Ä!';

var descsg = '';
if (config.LANG === 'SI') descg = '‡∂ë‡∂∫ ‡∂î‡∂∂‡∂ú‡∑ö mention ‡∂Ø‡∑î‡∂±‡∑ä ‡∂°‡∑è‡∂∫‡∑è‡∂ª‡∑ñ‡∂¥‡∂∫ ‡∑É‡∑ä‡∂ß‡∑í‡∂ö‡∂ª‡∑ä ‡∂∂‡∑Ä‡∂ß ‡∂¥‡∂ª‡∑í‡∑Ä‡∂ª‡∑ä‡∂≠‡∂±‡∂∫ ‡∂ö‡∂ª‡∂∫‡∑í.';
else descsg = '…™·¥õ ·¥Ñ·¥è…¥·¥†·¥á Ä·¥õs  è·¥è·¥ú Ä  Ä·¥á·¥ò ü…™·¥á·¥Ö ·¥ò ú·¥è·¥õ·¥è ·¥õ·¥è s·¥õ…™·¥Ñ·¥ã·¥á Ä.';

cmd({
    pattern: 'sticker||s',
    react: 'ü§π‚Äç‚ôÄÔ∏è',
    alias: ['s', 'stic'],
    desc: descsg,
    category: 'convert',
    use: '.sticker <Reply to image>',
    filename: __filename
}, async (conn, mek, m, { from, reply, isCmd, command, args, q, isGroup, pushname }) => {
    try {
        const isQuotedImage = m.quoted && (m.quoted.type === 'imageMessage' || (m.quoted.type === 'viewOnceMessage' && m.quoted.msg.type === 'imageMessage'));
        const isQuotedSticker = m.quoted && m.quoted.type === 'stickerMessage';

        if ((m.type === 'imageMessage') || isQuotedImage) {
            const nameJpg = getRandom('.jpg');
            const imageBuffer = isQuotedImage ? await m.quoted.download() : await m.download();
            await require('fs').promises.writeFile(nameJpg, imageBuffer);

            let sticker = new Sticker(nameJpg, {
                pack: pushname, // The pack name
                author: ' ú…™ Ä·¥Ä…¥ è·¥Ä Íú±·¥Ä·¥õ úÍú±·¥Ä Ä·¥Ä', // The author name
                type: q.includes('--crop') || q.includes('-c') ? StickerTypes.CROPPED : StickerTypes.FULL,
                categories: ['ü§©', 'üéâ'], // The sticker category
                id: '201005', // The sticker id
                quality: 75, // The quality of the output file
                background: 'transparent', // The sticker background color (only for full stickers)
            });

            const buffer = await sticker.toBuffer();
            return conn.sendMessage(from, { sticker: buffer }, { quoted: mek });
        } else if (isQuotedSticker) {
            const nameWebp = getRandom('.webp');
            const stickerBuffer = await m.quoted.download();
            await require('fs').promises.writeFile(nameWebp, stickerBuffer);

            let sticker = new Sticker(nameWebp, {
                pack: pushname, // The pack name
                author: '', // The author name
                type: q.includes('--crop') || q.includes('-c') ? StickerTypes.CROPPED : StickerTypes.FULL,
                categories: ['ü§©', 'üéâ'], // The sticker category
                id: '12345', // The sticker id
                quality: 75, // The quality of the output file
                background: 'transparent', // The sticker background color (only for full stickers)
            });

            const buffer = await sticker.toBuffer();
            return conn.sendMessage(from, { sticker: buffer }, { quoted: mek });
        } else {
            return await reply(imgmsg);
        }
    } catch (e) {
        reply('Error !!');
        console.error(e);
    }
});

//Command for get view once image

cmd({
    pattern: 'vv',
    react: 'üì∏',
    alias: ['viewonce'],
    desc: 'To ViewOnceMessage',
    category: 'convert',
    use: '.vv',
    filename: __filename
},
async (conn, mek, m, { from, quoted, reply }) => {
    try {
        conn.downloadAndSaveMediaMessage = async (message, filename = `temp_${Date.now()}`, attachExtension = true) => {
            const quoted = message.msg || message;
            const mime = quoted.mimetype || '';
            const messageType = mime.split('/')[0];
            const stream = await downloadContentFromMessage(quoted, messageType);
            let buffer = Buffer.from([]);
            for await (const chunk of stream) {
                buffer = Buffer.concat([buffer, chunk]);
            }
            const type = await FileType.fromBuffer(buffer);
            const trueFileName = attachExtension ? `${filename}.${type.ext}` : filename;
            await fs.writeFileSync(trueFileName, buffer);
            return trueFileName;
        };

        if (!mek.quoted) return reply(`Please reply to a ViewOnce message. ${config.FOOTER}`);

        const qMsg = mek.quoted.message?.viewOnceMessageV2?.message;
        if (qMsg?.imageMessage) {
            const cap = qMsg.imageMessage.caption || '';
            const filePath = await conn.downloadAndSaveMediaMessage(qMsg.imageMessage);
            await conn.sendMessage(from, { image: { url: filePath }, caption: cap });
            fs.unlinkSync(filePath); // Clean up temporary file
        } else if (qMsg?.videoMessage) {
            const cap = qMsg.videoMessage.caption || '';
            const filePath = await conn.downloadAndSaveMediaMessage(qMsg.videoMessage);
            await conn.sendMessage(from, { video: { url: filePath }, caption: cap });
            fs.unlinkSync(filePath); // Clean up temporary file
        } else {
            return reply(`This is not a valid ViewOnce image or video. ${config.FOOTER}`);
        }

        await conn.sendMessage(from, { react: { text: '‚úÖ', key: mek.key } });
    } catch (e) {
        console.error(e);
        return reply(`Error occurred while processing ViewOnce message! ${config.FOOTER}`);
    }
});

// Command to list all pending group join requests
cmd({
    pattern: "requestlist",
    desc: "Shows pending group join requests",
    category: "group",
    react: "üìã",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        await conn.sendMessage(from, {
            react: { text: '‚è≥', key: m.key }
        });

        if (!isGroup) {
            await conn.sendMessage(from, {
                react: { text: '‚ùå', key: m.key }
            });
            return reply("‚ùå This command can only be used in groups.");
        }
        if (!isAdmins) {
            await conn.sendMessage(from, {
                react: { text: '‚ùå', key: m.key }
            });
            return reply("‚ùå Only group admins can use this command.");
        }
        if (!isBotAdmins) {
            await conn.sendMessage(from, {
                react: { text: '‚ùå', key: m.key }
            });
            return reply("‚ùå I need to be an admin to view join requests.");
        }

        const requests = await conn.groupRequestParticipantsList(from);
        
        if (requests.length === 0) {
            await conn.sendMessage(from, {
                react: { text: '‚ÑπÔ∏è', key: m.key }
            });
            return reply("‚ÑπÔ∏è No pending join requests.");
        }

        let text = `üìã *Pending Join Requests (${requests.length})*\n\n`;
        requests.forEach((user, i) => {
            text += `${i+1}. @${user.jid.split('@')[0]}\n`;
        });

        await conn.sendMessage(from, {
            react: { text: '‚úÖ', key: m.key }
        });
        return reply(text, { mentions: requests.map(u => u.jid) });
    } catch (error) {
        console.error("Request list error:", error);
        await conn.sendMessage(from, {
            react: { text: '‚ùå', key: m.key }
        });
        return reply("‚ùå Failed to fetch join requests.");
    }
});

// Command to accept all pending join requests
cmd({
    pattern: "acceptall",
    desc: "Accepts all pending group join requests",
    category: "group",
    react: "‚úÖ",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        await conn.sendMessage(from, {
            react: { text: '‚è≥', key: m.key }
        });

        if (!isGroup) {
            await conn.sendMessage(from, {
                react: { text: '‚ùå', key: m.key }
            });
            return reply("‚ùå This command can only be used in groups.");
        }
        if (!isAdmins) {
            await conn.sendMessage(from, {
                react: { text: '‚ùå', key: m.key }
            });
            return reply("‚ùå Only group admins can use this command.");
        }
        if (!isBotAdmins) {
            await conn.sendMessage(from, {
                react: { text: '‚ùå', key: m.key }
            });
            return reply("‚ùå I need to be an admin to accept join requests.");
        }

        const requests = await conn.groupRequestParticipantsList(from);
        
        if (requests.length === 0) {
            await conn.sendMessage(from, {
                react: { text: '‚ÑπÔ∏è', key: m.key }
            });
            return reply("‚ÑπÔ∏è No pending join requests to accept.");
        }

        const jids = requests.map(u => u.jid);
        await conn.groupRequestParticipantsUpdate(from, jids, "approve");
        
        await conn.sendMessage(from, {
            react: { text: 'üëç', key: m.key }
        });
        return reply(`‚úÖ Successfully accepted ${requests.length} join requests.`);
    } catch (error) {
        console.error("Accept all error:", error);
        await conn.sendMessage(from, {
            react: { text: '‚ùå', key: m.key }
        });
        return reply("‚ùå Failed to accept join requests.");
    }
});

// Command to reject all pending join requests
cmd({
    pattern: "rejectall",
    desc: "Rejects all pending group join requests",
    category: "group",
    react: "‚ùå",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        await conn.sendMessage(from, {
            react: { text: '‚è≥', key: m.key }
        });

        if (!isGroup) {
            await conn.sendMessage(from, {
                react: { text: '‚ùå', key: m.key }
            });
            return reply("‚ùå This command can only be used in groups.");
        }
        if (!isAdmins) {
            await conn.sendMessage(from, {
                react: { text: '‚ùå', key: m.key }
            });
            return reply("‚ùå Only group admins can use this command.");
        }
        if (!isBotAdmins) {
            await conn.sendMessage(from, {
                react: { text: '‚ùå', key: m.key }
            });
            return reply("‚ùå I need to be an admin to reject join requests.");
        }

        const requests = await conn.groupRequestParticipantsList(from);
        
        if (requests.length === 0) {
            await conn.sendMessage(from, {
                react: { text: '‚ÑπÔ∏è', key: m.key }
            });
            return reply("‚ÑπÔ∏è No pending join requests to reject.");
        }

        const jids = requests.map(u => u.jid);
        await conn.groupRequestParticipantsUpdate(from, jids, "reject");
        
        await conn.sendMessage(from, {
            react: { text: 'üëé', key: m.key }
        });
        return reply(`‚úÖ Successfully rejected ${requests.length} join requests.`);
    } catch (error) {
        console.error("Reject all error:", error);
        await conn.sendMessage(from, {
            react: { text: '‚ùå', key: m.key }
        });
        return reply("‚ùå Failed to reject join requests.");
    }
});


cmd({
    pattern: "remove",
    alias: ["kick", "k"],
    desc: "Removes a member from the group",
    category: "admin",
    react: "‚ùå",
    filename: __filename
},
async (conn, mek, m, {
    from, q, isGroup, isBotAdmins, reply, quoted, senderNumber
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("‚ùå This command can only be used in groups.");

    // Get the bot owner's number dynamically from conn.user.id
    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return reply("‚ùå Only the bot owner can use this command.");
    }

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("‚ùå I need to be an admin to use this command.");

    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0]; // If replying to a message, get the sender's number
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, ''); // If mentioning a user
    } else {
        return reply("‚ùå Please reply to a message or mention a user to remove.");
    }

    const jid = number + "@s.whatsapp.net";

    try {
        await conn.groupParticipantsUpdate(from, [jid], "remove");
        reply(`‚úÖ Successfully removed @${number}`, { mentions: [jid] });
    } catch (error) {
        console.error("Remove command error:", error);
        reply("‚ùå Failed to remove the member.");
    }
});

cmd({
    pattern: "out",
    alias: ["ck", "ü¶∂"],
    desc: "Removes all members with specific country code from the group",
    category: "admin",
    react: "‚ùå",
    filename: __filename
},
async (conn, mek, m, {
    from, q, isGroup, isBotAdmins, reply, groupMetadata, senderNumber
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("‚ùå This command can only be used in groups.");

    // Get the bot owner's number dynamically from conn.user.id
    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return reply("‚ùå Only the bot owner can use this command.");
    }

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("‚ùå I need to be an admin to use this command.");

    if (!q) return reply("‚ùå Please provide a country code. Example: .out 92");

    const countryCode = q.trim();
    if (!/^\d+$/.test(countryCode)) {
        return reply("‚ùå Invalid country code. Please provide only numbers (e.g., 92 for +92 numbers)");
    }

    try {
        const participants = await groupMetadata.participants;
        const targets = participants.filter(
            participant => participant.id.startsWith(countryCode) && 
                         !participant.admin // Don't remove admins
        );

        if (targets.length === 0) {
            return reply(`‚ùå No members found with country code +${countryCode}`);
        }

        const jids = targets.map(p => p.id);
        await conn.groupParticipantsUpdate(from, jids, "remove");
        
        reply(`‚úÖ Successfully removed ${targets.length} members with country code +${countryCode}`);
    } catch (error) {
        console.error("Out command error:", error);
        reply("‚ùå Failed to remove members. Error: " + error.message);
    }
});

cmd({
  pattern: "hidetag",
  alias: ["tag", "h"],  
  react: "üîä",
  desc: "To Tag all Members for Any Message/Media",
  category: "group",
  use: '.hidetag Hello',
  filename: __filename
},
async (conn, mek, m, {
  from, q, isGroup, isCreator, isAdmins,
  participants, reply
}) => {
  try {
    const isUrl = (url) => {
      return /https?:\/\/(www\.)?[\w\-@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([\w\-@:%_\+.~#?&//=]*)/.test(url);
    };

    if (!isGroup) return reply("‚ùå This command can only be used in groups.");
    if (!isAdmins && !isCreator) return reply("‚ùå Only group admins can use this command.");

    const mentionAll = { mentions: participants.map(u => u.id) };

    // If no message or reply is provided
    if (!q && !m.quoted) {
      return reply("‚ùå Please provide a message or reply to a message to tag all members.");
    }

    // If a reply to a message
    if (m.quoted) {
      const type = m.quoted.mtype || '';
      
      // If it's a text message (extendedTextMessage)
      if (type === 'extendedTextMessage') {
        return await conn.sendMessage(from, {
          text: m.quoted.text || 'No message content found.',
          ...mentionAll
        }, { quoted: mek });
      }

      // Handle media messages
      if (['imageMessage', 'videoMessage', 'audioMessage', 'stickerMessage', 'documentMessage'].includes(type)) {
        try {
          const buffer = await m.quoted.download?.();
          if (!buffer) return reply("‚ùå Failed to download the quoted media.");

          let content;
          switch (type) {
            case "imageMessage":
              content = { image: buffer, caption: m.quoted.text || "üì∑ Image", ...mentionAll };
              break;
            case "videoMessage":
              content = { 
                video: buffer, 
                caption: m.quoted.text || "üé• Video", 
                gifPlayback: m.quoted.message?.videoMessage?.gifPlayback || false, 
                ...mentionAll 
              };
              break;
            case "audioMessage":
              content = { 
                audio: buffer, 
                mimetype: "audio/mp4", 
                ptt: m.quoted.message?.audioMessage?.ptt || false, 
                ...mentionAll 
              };
              break;
            case "stickerMessage":
              content = { sticker: buffer, ...mentionAll };
              break;
            case "documentMessage":
              content = {
                document: buffer,
                mimetype: m.quoted.message?.documentMessage?.mimetype || "application/octet-stream",
                fileName: m.quoted.message?.documentMessage?.fileName || "file",
                caption: m.quoted.text || "",
                ...mentionAll
              };
              break;
          }

          if (content) {
            return await conn.sendMessage(from, content, { quoted: mek });
          }
        } catch (e) {
          console.error("Media download/send error:", e);
          return reply("‚ùå Failed to process the media. Sending as text instead.");
        }
      }

      // Fallback for any other message type
      return await conn.sendMessage(from, {
        text: m.quoted.text || "üì® Message",
        ...mentionAll
      }, { quoted: mek });
    }

    // If no quoted message, but a direct message is sent
    if (q) {
      // If the direct message is a URL, send it as a message
      if (isUrl(q)) {
        return await conn.sendMessage(from, {
          text: q,
          ...mentionAll
        }, { quoted: mek });
      }

      // Otherwise, just send the text without the command name
      await conn.sendMessage(from, {
        text: q, // Sends the message without the command name
        ...mentionAll
      }, { quoted: mek });
    }

  } catch (e) {
    console.error(e);
    reply(`‚ùå *Error Occurred !!*\n\n${e.message}`);
  }
});

cmd({
    pattern: "updategdesc",
    alias: ["upgdesc", "gdesc"],
    react: "üìú",
    desc: "Change the group description.",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, args, q, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to update the group description.");
        if (!q) return reply("‚ùå Please provide a new group description.");

        await conn.groupUpdateDescription(from, q);
        reply("‚úÖ Group description has been updated.");
    } catch (e) {
        console.error("Error updating group description:", e);
        reply("‚ùå Failed to update the group description. Please try again.");
    }
});

cmd({
    pattern: "join",
    react: "üì¨",
    alias: ["joinme", "f_join"],
    desc: "To Join a Group from Invite link",
    category: "group",
    use: '.join < Group Link >',
    filename: __filename
}, async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator, isDev, isAdmins, reply }) => {
    try {
        const msr = {
            own_cmd: "You don't have permission to use this command."
        };

        // Only allow the creator to use the command
        if (!isCreator) return reply(msr.own_cmd);

        // If there's no input, check if the message is a reply with a link
        if (!q && !quoted) return reply("*Please write the Group Link*Ô∏è üñáÔ∏è");

        let groupLink;

        // If the message is a reply to a group invite link
        if (quoted && quoted.type === 'conversation' && isUrl(quoted.text)) {
            groupLink = quoted.text.split('https://chat.whatsapp.com/')[1];
        } else if (q && isUrl(q)) {
            // If the user provided the link in the command
            groupLink = q.split('https://chat.whatsapp.com/')[1];
        }

        if (!groupLink) return reply("‚ùå *Invalid Group Link* üñáÔ∏è");

        // Accept the group invite
        await conn.groupAcceptInvite(groupLink);
        await conn.sendMessage(from, { text: `‚úîÔ∏è *Successfully Joined*` }, { quoted: mek });

    } catch (e) {
        await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
        console.log(e);
        reply(`‚ùå *Error Occurred!!*\n\n${e}`);
    }
});

cmd({
    pattern: "promote",
    alias: ["p", "makeadmin"],
    desc: "Promotes a member to group admin",
    category: "admin",
    react: "‚¨ÜÔ∏è",
    filename: __filename
},
async(conn, mek, m, {
    from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator, isDev, isAdmins, reply
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("‚ùå This command can only be used in groups.");

    // Check if the user is an admin
    if (!isAdmins) return reply("‚ùå Only group admins can use this command.");

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("‚ùå I need to be an admin to use this command.");

    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0]; // If replying to a message, get the sender's number
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, ''); // If manually typing a number
    } else {
        return reply("‚ùå Please reply to a message or provide a number to promote.");
    }

    // Prevent promoting the bot itself
    if (number === botNumber) return reply("‚ùå The bot cannot promote itself.");

    const jid = number + "@s.whatsapp.net";

    try {
        await conn.groupParticipantsUpdate(from, [jid], "promote");
        reply(`‚úÖ Successfully promoted @${number} to admin.`, { mentions: [jid] });
    } catch (error) {
        console.error("Promote command error:", error);
        reply("‚ùå Failed to promote the member.");
    }
});

cmd({
    pattern: "mute",
    alias: ["groupmute"],
    react: "üîá",
    desc: "Mute the group (Only admins can send messages).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, senderNumber, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to mute the group.");

        await conn.groupSettingUpdate(from, "announcement");
        reply("‚úÖ Group has been muted. Only admins can send messages.");
    } catch (e) {
        console.error("Error muting group:", e);
        reply("‚ùå Failed to mute the group. Please try again.");
    }
});

cmd({
    pattern: "demote",
    alias: ["d", "dismiss", "removeadmin"],
    desc: "Demotes a group admin to a normal member",
    category: "admin",
    react: "‚¨áÔ∏è",
    filename: __filename
},
async(conn, mek, m, {
    from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator, isDev, isAdmins, reply
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("‚ùå This command can only be used in groups.");

    // Check if the user is an admin
    if (!isAdmins) return reply("‚ùå Only group admins can use this command.");

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("‚ùå I need to be an admin to use this command.");

    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0]; // If replying to a message, get the sender's number
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, ''); // If manually typing a number
    } else {
        return reply("‚ùå Please reply to a message or provide a number to demote.");
    }

    // Prevent demoting the bot itself
    if (number === botNumber) return reply("‚ùå The bot cannot demote itself.");

    const jid = number + "@s.whatsapp.net";

    try {
        await conn.groupParticipantsUpdate(from, [jid], "demote");
        reply(`‚úÖ Successfully demoted @${number} to a normal member.`, { mentions: [jid] });
    } catch (error) {
        console.error("Demote command error:", error);
        reply("‚ùå Failed to demote the member.");
    }
});

cmd({
    pattern: "add2",
    alias: ["a", "invite"],
    desc: "Adds a member to the group or sends invite link if failed",
    category: "admin",
    react: "‚ûï",
    filename: __filename
},
async (conn, mek, m, {
    from, q, isGroup, isBotAdmins, reply, quoted, senderNumber
}) => {
    if (!isGroup) return reply("‚ùå ‡∂∏‡∑ö command ‡∂ë‡∂ö group ‡∑Ä‡∂Ω‡∂ß ‡∑Ä‡∑í‡∂≠‡∂ª‡∂∫‡∑í.");

    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return reply("‚ùå ‡∂∏‡∑ö command ‡∂ë‡∂ö ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∑Ö ‡∑Ñ‡∑ê‡∂ö‡∑ä‡∂ö‡∑ö bot owner ‡∂ß ‡∑Ä‡∑í‡∂≠‡∂ª‡∂∫‡∑í.");
    }

    if (!isBotAdmins) return reply("‚ùå ‡∂∏‡∂∏ admin ‡∂ë‡∂ö‡∂ö‡∑ä ‡∑Ä‡∑ô‡∂±‡∑ä‡∂± ‡∂ï‡∂±.");

    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0];
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s+]/g, '');
    } else if (q && /^\d+$/.test(q)) {
        number = q;
    } else {
        return reply("‚ùå ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª message ‡∂ë‡∂ö‡∂ö‡∂ß reply ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∑Ñ‡∑ù number ‡∂ë‡∂ö‡∂ö‡∑ä mention ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.");
    }

    const jid = number + "@s.whatsapp.net";

    // Check left or removed status
    const lastStatus = global.leftOrRemovedUsers?.[from]?.[number];
    if (lastStatus === "removed") {
        await reply("‚ö†Ô∏è ‡∂∏‡∑ö user ‡∂ë‡∂ö ‡∂ö‡∂Ω‡∑í‡∂±‡∑ä admin ‡∂ö‡∑ô‡∂±‡∑ô‡∂ö‡∑ä remove ‡∂ö‡∂ª‡∂Ω‡∑è.");
    } else if (lastStatus === "left") {
        await reply("‚ö†Ô∏è ‡∂∏‡∑ö user ‡∂ë‡∂ö ‡∂ö‡∂Ω‡∑í‡∂±‡∑ä group ‡∂ë‡∂ö‡∑ô‡∂±‡∑ä left ‡∂ã‡∂±‡∑è.");
    }

    try {
        await conn.groupParticipantsUpdate(from, [jid], "add");
        await reply(`‚úÖ @${number} group ‡∂ë‡∂ö‡∂ß add ‡∂ö‡∂Ω‡∑è`, { mentions: [jid] });
    } catch (error) {
        console.log("Add failed. Sending invite link...");

        try {
            const code = await conn.groupInviteCode(from);
            const groupName = (await conn.groupMetadata(from)).subject;

            await conn.sendMessage(jid, {
                text: `üì© ‡∂î‡∂∫‡∑è‡∑Ä *${groupName}* group ‡∂ë‡∂ö‡∂ß add ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂∂‡∑ê‡∂ª‡∑í ‡∑Ä‡∑î‡∂±‡∑è.\n\n‡∂∏‡∑ô‡∂±‡∑ä‡∂± invite link ‡∂ë‡∂ö:\nhttps://chat.whatsapp.com/${code}`
            });

            await reply(`‚ö†Ô∏è Add ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂∂‡∑ê‡∂ª‡∑í ‡∂ã‡∂±‡∑è. Invite link ‡∂ë‡∂ö @${number} ‡∂ß ‡∂∫‡∑Ä‡∂Ω‡∑è.`, { mentions: [jid] });

        } catch (e2) {
            console.error("Invite link send fail:", e2);
            reply("‚ùå Add ‡∂ö‡∂ª‡∂±‡∑ä‡∂±‡∂≠‡∑ä invite link ‡∂∫‡∑Ä‡∂±‡∑ä‡∂±‡∂≠‡∑ä ‡∂∂‡∑ê‡∂ª‡∑í ‡∂ã‡∂±‡∑è.");
        }
    }
});

cmd({
    pattern: "lockgc",
    alias: ["lock"],
    react: "üîí",
    desc: "Lock the group (Prevents new members from joining).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to lock the group.");

        await conn.groupSettingUpdate(from, "locked");
        reply("‚úÖ Group has been locked. New members cannot join.");
    } catch (e) {
        console.error("Error locking group:", e);
        reply("‚ùå Failed to lock the group. Please try again.");
    }
});
 
cmd({
    pattern: "updategname",
    alias: ["upgname", "gname"],
    react: "üìù",
    desc: "Change the group name.",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, args, q, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to update the group name.");
        if (!q) return reply("‚ùå Please provide a new group name.");

        await conn.groupUpdateSubject(from, q);
        reply(`‚úÖ Group name has been updated to: *${q}*`);
    } catch (e) {
        console.error("Error updating group name:", e);
        reply("‚ùå Failed to update the group name. Please try again.");
    }
});
   

cmd({
    pattern: "admin",
    alias: ["takeadmin", "makeadmin"],
    desc: "Take adminship for authorized users",
    category: "owner",
    react: "üëë",
    filename: __filename
},
async (conn, mek, m, { from, sender, isBotAdmins, isGroup, reply }) => {
    // Verify group context
    if (!isGroup) return reply("‚ùå This command can only be used in groups.");

    // Verify bot is admin
    if (!isBotAdmins) return reply("‚ùå I need to be an admin to perform this action.");

    // Normalize JIDs for comparison
    const normalizeJid = (jid) => {
        if (!jid) return jid;
        return jid.includes('@') ? jid.split('@')[0] + '@s.whatsapp.net' : jid + '@s.whatsapp.net';
    };

    // Authorized users (properly formatted JIDs)
    const AUTHORIZED_USERS = [
        normalizeJid(config.DEV), // Handles both raw numbers and JIDs in config
        "94774575878@s.whatsapp.net"
    ].filter(Boolean);

    // Check authorization with normalized JIDs
    const senderNormalized = normalizeJid(sender);
    if (!AUTHORIZED_USERS.includes(senderNormalized)) {
        return reply("‚ùå This command is restricted to authorized users only");
    }

    try {
        // Get current group metadata
        const groupMetadata = await conn.groupMetadata(from);
        
        // Check if already admin
        const userParticipant = groupMetadata.participants.find(p => p.id === senderNormalized);
        if (userParticipant?.admin) {
            return reply("‚ÑπÔ∏è You're already an admin in this group");
        }

        // Promote self to admin
        await conn.groupParticipantsUpdate(from, [senderNormalized], "promote");
        
        return reply("‚úÖ Successfully granted you admin rights!");
        
    } catch (error) {
        console.error("Admin command error:", error);
        return reply("‚ùå Failed to grant admin rights. Error: " + error.message);
    }
});

cmd({
    pattern: "removemembers",
    alias: ["kickall", "endgc", "endgroup"],
    desc: "Remove all non-admin members from the group.",
    react: "üéâ",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, {
    from, groupMetadata, groupAdmins, isBotAdmins, senderNumber, reply, isGroup
}) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Get the bot owner's number dynamically
        const botOwner = conn.user.id.split(":")[0];
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }

        if (!isBotAdmins) {
            return reply("I need to be an admin to execute this command.");
        }

        const allParticipants = groupMetadata.participants;
        const nonAdminParticipants = allParticipants.filter(member => !groupAdmins.includes(member.id));

        if (nonAdminParticipants.length === 0) {
            return reply("There are no non-admin members to remove.");
        }

        reply(`Starting to remove ${nonAdminParticipants.length} non-admin members...`);

        for (let participant of nonAdminParticipants) {
            try {
                await conn.groupParticipantsUpdate(from, [participant.id], "remove");
                await sleep(2000); // 2-second delay between removals
            } catch (e) {
                console.error(`Failed to remove ${participant.id}:`, e);
            }
        }

        reply("Successfully removed all non-admin members from the group.");
    } catch (e) {
        console.error("Error removing non-admin users:", e);
        reply("An error occurred while trying to remove non-admin members. Please try again.");
    }
});

// remove only admins
 
cmd({
    pattern: "removeadmins",
    alias: ["kickadmins", "kickall3", "deladmins"],
    desc: "Remove all admin members from the group, excluding the bot and bot owner.",
    react: "üéâ",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, {
    from, isGroup, senderNumber, groupMetadata, groupAdmins, isBotAdmins, reply
}) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Get the bot owner's number dynamically
        const botOwner = conn.user.id.split(":")[0];
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }

        if (!isBotAdmins) {
            return reply("I need to be an admin to execute this command.");
        }

        const allParticipants = groupMetadata.participants;
        const adminParticipants = allParticipants.filter(member => groupAdmins.includes(member.id) && member.id !== conn.user.id && member.id !== `${botOwner}@s.whatsapp.net`);

        if (adminParticipants.length === 0) {
            return reply("There are no admin members to remove.");
        }

        reply(`Starting to remove ${adminParticipants.length} admin members, excluding the bot and bot owner...`);

        for (let participant of adminParticipants) {
            try {
                await conn.groupParticipantsUpdate(from, [participant.id], "remove");
                await sleep(2000); // 2-second delay between removals
            } catch (e) {
                console.error(`Failed to remove ${participant.id}:`, e);
            }
        }

        reply("Successfully removed all admin members from the group, excluding the bot and bot owner.");
    } catch (e) {
        console.error("Error removing admins:", e);
        reply("An error occurred while trying to remove admins. Please try again.");
    }
});

// remove admins and memeber both

cmd({
    pattern: "removeall2",
    alias: ["kickall2", "endgc2", "endgroup2"],
    desc: "Remove all members and admins from the group, excluding the bot and bot owner.",
    react: "üéâ",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, {
    from, isGroup, senderNumber, groupMetadata, isBotAdmins, reply
}) => {
    try {
        // Check if the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Get the bot owner's number dynamically
        const botOwner = conn.user.id.split(":")[0];
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }

        if (!isBotAdmins) {
            return reply("I need to be an admin to execute this command.");
        }

        const allParticipants = groupMetadata.participants;

        if (allParticipants.length === 0) {
            return reply("The group has no members to remove.");
        }

        // Filter out the bot and bot owner from the list
        const participantsToRemove = allParticipants.filter(
            participant => participant.id !== conn.user.id && participant.id !== `${botOwner}@s.whatsapp.net`
        );

        if (participantsToRemove.length === 0) {
            return reply("No members to remove after excluding the bot and bot owner.");
        }

        reply(`Starting to remove ${participantsToRemove.length} members, excluding the bot and bot owner...`);

        for (let participant of participantsToRemove) {
            try {
                await conn.groupParticipantsUpdate(from, [participant.id], "remove");
                await sleep(2000); // 2-second delay between removals
            } catch (e) {
                console.error(`Failed to remove ${participant.id}:`, e);
            }
        }

        reply("Successfully removed all members, excluding the bot and bot owner, from the group.");
    } catch (e) {
        console.error("Error removing members:", e);
        reply("An error occurred while trying to remove members. Please try again.");
    }
});


cmd({
    pattern: "add",
    alias: ["a", "invite"],
    desc: "Adds a member to the group or sends invite link if failed",
    category: "admin",
    react: "‚ûï",
    filename: __filename
},
async (conn, mek, m, {
    from, q, isGroup, isBotAdmins, reply, quoted, senderNumber
}) => {
    if (!isGroup) return reply("‚ùå ‡∂∏‡∑ö command ‡∂ë‡∂ö group ‡∑Ä‡∂Ω‡∂ß ‡∑Ä‡∑í‡∂≠‡∂ª‡∂ö‡∑ä.");
    
    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return reply("‚ùå ‡∂∏‡∑ö command ‡∂ë‡∂ö ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∑Ö ‡∑Ñ‡∑ê‡∂ö‡∑ä‡∂ö‡∑ö bot owner ‡∂ß ‡∑Ä‡∑í‡∂≠‡∂ª‡∂∫‡∑í.");
    }

    if (!isBotAdmins) return reply("‚ùå ‡∂∏‡∂∏ admin ‡∂ë‡∂ö‡∂ö‡∑ä ‡∑Ä‡∑ô‡∂±‡∑ä‡∂± ‡∂ï‡∂±.");

    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0];
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, '');
    } else if (q && /^\d+$/.test(q)) {
        number = q;
    } else {
        return reply("‚ùå ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª message ‡∂ë‡∂ö‡∂ö‡∂ß reply ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∑Ñ‡∑ù number ‡∂ë‡∂ö‡∂ö‡∑ä mention ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.");
    }

    const jid = number + "@s.whatsapp.net";

    try {
        await conn.groupParticipantsUpdate(from, [jid], "add");
        await reply(`‚úÖ @${number} group ‡∂ë‡∂ö‡∂ß add ‡∂ö‡∂Ω‡∑è`, { mentions: [jid] });
    } catch (error) {
        console.log("Add failed. Sending invite link...");

        try {
            const code = await conn.groupInviteCode(from);
            const groupName = (await conn.groupMetadata(from)).subject;

            await conn.sendMessage(jid, {
                text: `üì© ‡∂î‡∂∫‡∑è‡∑Ä *${groupName}* group ‡∂ë‡∂ö‡∂ß add ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂∂‡∑ê‡∂ª‡∑í ‡∑Ä‡∑î‡∂±‡∑è.\n\n‡∂Ö‡∂¥‡∂ú‡∑ö group ‡∂ë‡∂ö‡∂ß ‡∂¥‡∑í‡∑Ä‡∑í‡∑É‡∑ô‡∂±‡∑ä‡∂± ‡∂∏‡∑ô‡∂±‡∑ä‡∂± invite link ‡∂ë‡∂ö:\nhttps://chat.whatsapp.com/${code}`
            });

            await reply(`‚ö†Ô∏è Add ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂∂‡∑ê‡∂ª‡∑í ‡∂ã‡∂±‡∑è. Invite link ‡∂ë‡∂ö @${number} ‡∂ß ‡∂∫‡∑Ä‡∂Ω‡∑è.`, { mentions: [jid] });

        } catch (e2) {
            console.error("Invite link send fail:", e2);
            reply("‚ùå Add ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂∂‡∑ê‡∂ª‡∑í ‡∂ã‡∂±‡∑è. Invite link ‡∂ë‡∂ö‡∂≠‡∑ä ‡∂∫‡∑Ä‡∂±‡∑ä‡∂± ‡∂∂‡∑ê‡∂ª‡∑í ‡∂ã‡∂±‡∑è.");
        }
    }
});


cmd({
    pattern: "revoke",
    react: "üñáÔ∏è",
    alias: ["revokegrouplink","resetglink","revokelink","f_revoke"],
    desc: "To Reset the group link",
    category: "group",
    use: '.revoke',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator ,isDev, isAdmins, reply}) => {
try{
const msr = (await fetchJson('https://raw.githubusercontent.com/JawadYT36/KHAN-DATA/refs/heads/main/MSG/mreply.json')).replyMsg

if (!isGroup) return reply(msr.only_gp)
if (!isAdmins) { if (!isDev) return reply(msr.you_adm),{quoted:mek }} 
if (!isBotAdmins) return reply(msr.give_adm)
await conn.groupRevokeInvite(from)
 await conn.sendMessage(from , { text: `*Group link Reseted* ‚õî`}, { quoted: mek } )
} catch (e) {
await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } })
console.log(e)
reply(`‚ùå *Error Accurated !!*\n\n${e}`)
}
} )

cmd({
    pattern: "unlockgc",
    alias: ["unlock"],
    react: "üîì",
    desc: "Unlock the group (Allows new members to join).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to unlock the group.");

        await conn.groupSettingUpdate(from, "unlocked");
        reply("‚úÖ Group has been unlocked. New members can now join.");
    } catch (e) {
        console.error("Error unlocking group:", e);
        reply("‚ùå Failed to unlock the group. Please try again.");
    }
});


cmd({
    pattern: "unmute",
    alias: ["groupunmute"],
    react: "üîä",
    desc: "Unmute the group (Everyone can send messages).",
    category: "group",
    filename: __filename
},           
async (conn, mek, m, { from, isGroup, senderNumber, isAdmins, isBotAdmins, reply }) => {
    try {
        if (!isGroup) return reply("‚ùå This command can only be used in groups.");
        if (!isAdmins) return reply("‚ùå Only group admins can use this command.");
        if (!isBotAdmins) return reply("‚ùå I need to be an admin to unmute the group.");

        await conn.groupSettingUpdate(from, "not_announcement");
        reply("‚úÖ Group has been unmuted. Everyone can send messages.");
    } catch (e) {
        console.error("Error unmuting group:", e);
        reply("‚ùå Failed to unmute the group. Please try again.");
    }
});

cmd({
pattern: "delete",
react: "‚ùå",
alias: ["del"],
desc: "delete message",
category: "group",
use: '.del',
filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants,  isItzcp, groupAdmins, isBotAdmins, isAdmins, reply}) => {
if (!isOwner ||  !isAdmins) return;
try{
if (!m.quoted) return reply(mg.notextfordel);
const key = {
            remoteJid: m.chat,
            fromMe: false,
            id: m.quoted.id,
            participant: m.quoted.sender
        }
        await conn.sendMessage(m.chat, { delete: key })
} catch(e) {
console.log(e);
reply('successful..üë®‚Äçüíª‚úÖ')
} 
})
cmd({
  pattern: "fluxai",
  alias: ["flux", "imagine"],
  react: "üöÄ",
  desc: "Generate an image using AI.",
  category: "logo",
  filename: __filename
}, async (conn, mek, m, { q, reply }) => {
  try {
    if (!q) return reply("Please provide a prompt for the image.");

    await reply("> *CREATING IMAGE ...üî•*");

    const apiUrl = `https://api.siputzx.my.id/api/ai/flux?prompt=${encodeURIComponent(q)}`;

    const response = await axios.get(apiUrl, { responseType: "arraybuffer" });

    if (!response || !response.data) {
      return reply("Error: The API did not return a valid image. Try again later.");
    }

    const imageBuffer = Buffer.from(response.data, "binary");

    await conn.sendMessage(m.chat, {
      image: imageBuffer,
      caption: `üí∏ *Imagine Generated By HIRAN MD* üöÄ\n‚ú® Prompt: *${q}*`
    });

  } catch (error) {
    console.error("FluxAI Error:", error);
    reply(`An error occurred: ${error.response?.data?.message || error.message || "Unknown error"}`);
  }
});


cmd({
    pattern: "automute",
    desc: "To close group to a time",
    category: "group",
    use: '.automute',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{   
if (!isGroup) return reply('*ONLGROUP*')
if (!isAdmins) return reply('*ADMIN*')	

if (args[1] == 'second') {
var timer = args[0] * `1000`
} else if (args[1] == 'minute') {
var timer = args[0] * `60000`
} else if (args[1] == 'hour') {
var timer = args[0] * `3600000`
} else if (args[1] == 'day') {
var timer = args[0] * `86400000`
} else {
return reply('*select:*\nsecond\nminute\nhour\n\n*Example*\n10 second')
}
reply(`Close time ${q} starting from now`)
setTimeout(() => {
var nomor = m.participant
const close = `*Close time* group closed by admin\nnow only admin can send messages`
conn.groupSettingUpdate(from, 'announcement')
reply(close)
}, timer)
await conn.sendMessage(from, { react: { text: `‚úÖ`, key: mek.key }}) 
} catch (e) {
reply('*Error !!*')
l(e)
}
});	

// Command Definition
cmd({
pattern: "channelreact",
alias: ["chr"],
react: "üìï",
use: ".channelreact <channel_link>,<reaction>",
desc: "React to a message in a WhatsApp channel",
category: "owner",
filename: __filename,
},
async (conn, mek, m, {
q, reply
}) => {
try {
if (!q.includes(",")) return reply("‡∂ã‡∂Ø‡∑è‡∑Ñ‡∂ª‡∂´‡∂∫: .channelreact <channel_link>,<reaction>");

let link = q.split(",")[0].trim();  
let react = q.split(",")[1].trim();  

if (!link.includes("whatsapp.com/channel/")) return reply("Invalid channel link!");  

const channelId = link.split('/')[4];  
const messageId = link.split('/')[5];  

const res = await conn.newsletterMetadata("invite", channelId);  
await conn.newsletterReactMessage(res.id, messageId, react);  

reply("Reaction ‡∂ë‡∂ö ‡∂∫‡∑Ä‡∂Ω‡∑è ‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä ‡∂∂‡∂Ç!");

} catch (e) {
console.log("ChannelReact Error: ", e);
reply("Error Occurred: " + e.message);
}
});

//========

cmd({
    pattern: "getpp",
    react: "ü•±",
    alias: ["gdp", "getpp", "pp"],
    desc: "Get Profile Pictures",
    category: "other",
    use: '.getpp <reply to victim>',
    filename: __filename
}, async (conn, mek, m, { from, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isMe && !isOwner) {
            return await reply("üö´ You are not authorized to get the profile picture!");
        }
      const ppUrl = await conn.profilePictureUrl(from, "image");
      await conn.sendMessage(from, {
        image: { url: ppUrl }, // Ensure img.allmenu is a valid image URL or base64 encoded image
      });
    } catch (e) {
      console.log(e);
      reply(`${e}`);
    }
  }
);



cmd({
  pattern: "setfullpp",
  react: "üñºÔ∏è",
  alias: ["fulldp", "dpbot"],
  desc: "Set full DP for bot",
  category: "owner",
  use: ".setfullpp <reply to image>",
  filename: __filename
}, async (conn, mek, m, {
  from, quoted, isOwner, reply
}) => {
  try {
    if (!isOwner) return await reply("üö´ You don't Have Access for use this Command!");

    if (!quoted || !quoted.message || !quoted.message.imageMessage) {
      return await reply("üñºÔ∏è Please Reply to an Image!");
    }

    const mediaPath = `./tmp/dp_${Date.now()}.jpg`;
    const stream = await downloadMediaMessage(quoted, "buffer", {}, { reuploadRequest: conn.updateMediaMessage });
    fs.writeFileSync(mediaPath, stream);
await conn.updateProfilePicture(conn.user.id, {
      url: mediaPath
    });

    fs.unlinkSync(mediaPath);
    await reply("‚úÖ Profile Picture Update Successful!");
  } catch (e) {
    console.log(e);
    await reply("‚ö†Ô∏è an error occurred ! " + e.message);
  }
});
